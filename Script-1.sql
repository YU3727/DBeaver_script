--TABLE의 모든 정보를 보기
SELECT * FROM tab; --hr이 가지고있는 모든(*) tables의 목록을 보여달라는 뜻

--대륙정보
SELECT * FROM REGIONS; --지역ID(대륙번호)

--국가정보
SELECT * FROM COUNTRIES; --국가ID, 국가명, 지역ID(대륙번호인듯?)

--위치정보
SELECT * FROM LOCATIONS; --위치ID, 길의 이름, 도시명, 주명, 국가ID

--부서정보
SELECT * FROM DEPARTMENTS; --부서ID, 부서명, 관리자ID, 부서위치

--직원정보
SELECT * FROM EMPLOYEES;


SELECT * FROM EMP_DETAILS_VIEW;

--직급정보
SELECT * FROM JOBS; --직업ID, 직업명, 최소~최대 월급

--직급변동기록(승진/퇴사 등)
SELECT * FROM JOB_HISTORY;


-----------------------------------------------------------
--230117 1~4교시 DML - SELECT

DESC LOCATIONS; --이건안되네


SELECT *
FROM LOCATIONS;

--LOCATIONS에서 원하는 column만 보고싶을때(순서무관)
SELECT CITY, POSTAL_CODE
FROM LOCATIONS;

SELECT *
FROM EMPLOYEES;

--SELECT를 이용하여 특정정보만 보기(사원들의 성, 이름, 월급, 입사일)
--쌍따옴표("")는 별칭주고 띄워쓰기 할 때 쓴다.
SELECT LAST_NAME, FIRST_NAME, SALARY, SALARY*12 AS "YEAR SALARY", (SALARY*12)-5000 SAL, HIRE_DATE 입사일 --같은컬럼을 여러번 불러오기도 가능, 계산된 결과도 볼 수 있음
FROM EMPLOYEES;                      --SALARY*12, (SALARY*12)-5000은 실제 컬럼명이 없기 떄문에 그대로 컬럼명에 들어간다.

--SELECT를 이용하여 함수 호출도 가능하다
SELECT SUM(SALARY)/COUNT(EMPLOYEE_ID), AVG(SALARY) 
FROM EMPLOYEES;

--DISTINCT (중복제거) - 한번만 사용 가능하다
SELECT DISTINCT DEPARTMENTD, EMPLOYEE_ID --DISTINCT SALARY
FROM EMPLOYEES;

SELECT STATE_PROVINCE || ' 의 도시명은 ' || CITY --STATE ~ CITY 까지 전체다가 컬럼명이 됨.
FROM LOCATIONS;

--WHERE : 조건식이 TRUE인 값만 불러오는 것
--이름, 월급, 부서번호 Column을 불러오고, 그중에서 부서번호90인 사람을 찾자
--돌아가는 순서 : FROM -> WHERE -> SELECT
SELECT FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 90; --SQL은 프로그램에 질의(질문)하는 언어. 대입할 일이 없고 물어보면 됨.

--사원의 정보중에서 사원의ID, 직급, 입사일, 월급을 출력
--월급이 15000 이상인 사원만 출력
SELECT FIRST_NAME, LAST_NAME, JOB_ID, HIRE_DATE, SALARY, DEPARTMENT_ID 
FROM EMPLOYEES
WHERE SALARY >= 8000 AND DEPARTMENT_ID = 100;

--ERROR : 그룹함수는 허가되지 않음.(월급이 평균월급보다 많이 받는 사람들 찾기)
SELECT FIRST_NAME, LAST_NAME, JOB_ID, HIRE_DATE, SALARY, DEPARTMENT_ID 
FROM EMPLOYEES
WHERE SALARY >= AVG(SALARY);

-- = NULL은 아예 데이터값이 없는게 조회됨, NULL인것을 찾고싶으면 IS NULL;
SELECT *
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NULL;

SELECT *
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;

--사원의 모든 정보
--급여가 8000이상 15000이하
SELECT *
FROM EMPLOYEES
WHERE SALARY >= 8000 AND SALARY <= 15000;
-- BETWEEN 연산자 : 같은 COLUMN을 AND 연산 할때 사용
SELECT *
FROM EMPLOYEES
WHERE SALARY BETWEEN 8000 AND 15000; --BETWEEN : ~이상 ~이하

--사원의 모든 정보
--부서번호가 60, 100인 사원들
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60 OR DEPARTMENT_ID = 100;
-- IN 연산자 : OR같은 역할
SELECT *
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID IN (60, 100);

--사원의 모든 정보, Last name이 Austin인 사람
SELECT *
FROM EMPLOYEES e 
WHERE LAST_NAME = 'Austin'; --문자열은 컬럼명과 구분하기 위해서 앞뒤로 홑따옴표('')를 써야한다, 숫자는 상관x

--사원의 모든 정보, 2004년 1월 1일 이후에 입사한 사람들
SELECT *
FROM EMPLOYEES e 
WHERE HIRE_DATE >= '2004-01-01';

--LIKE : 특정 문자열에 일치하는 데이터를 조회
--이런건 쇼핑몰에서 검색할때 많이 쓴다.
SELECT *
FROM EMPLOYEES e 
WHERE LAST_NAME LIKE '%k%';

--ESCAPE 옵션 : 예약어(%, _)를 문자열에 포함해서 검색하고 싶을 때 사용

--정렬 ORDER BY
--사원의 급여 순으로
SELECT LAST_NAME, SALARY
FROM EMPLOYEES e 
ORDER BY SALARY DESC;

--SALARY 내림차순 정렬, 같은 SALARY끼리는 LAST_NAME 오름차순 정렬
SELECT LAST_NAME, SALARY
FROM EMPLOYEES e 
ORDER BY 2 DESC, LAST_NAME ASC;

--LAST_NAME 기준으로 오름차순 정렬
-- ORDER BY는 SELECT 이후 쿼리문이 진행되므로, 'SELECT의 결과물 중 2번째 데이터'를 기준으로 오름차순정렬을 이런식으로도 쓸 수 있음
SELECT LAST_NAME , SALARY 
FROM EMPLOYEES e 
ORDER BY 1 ASC;

--사원의 모든정보, 입사 순으로(오름차순)
SELECT *
FROM EMPLOYEES e 
ORDER BY HIRE_DATE ASC;


--NOTION 실습문제

--1.사원정보(employees) 테이블에서 사원번호, 이름, 급여, 업무, 입사일, 상사의 사원번호를 출력
SELECT EMPLOYEE_ID , FIRST_NAME , SALARY , JOB_ID , HIRE_DATE , MANAGER_ID 
FROM EMPLOYEES e ;

--2.사원정보(employees) 테이블에서 사원의 이름, 성, 급여와 연봉에 $100 보너스를 추가하여 계산한 값은 Increased Ann_Salary,
--급여에 $100 보너스를 추가하여 계산한 연봉은 Increased Salary라는 별칭을 붙여 출력
SELECT FIRST_NAME , LAST_NAME , SALARY , SALARY *12 ,(SALARY *12)+100 AS "Increased Ann_Salary", SALARY+100 AS "Increased Salary" 
FROM EMPLOYEES e 

--3.예산 편성 문제로 급여 정보 보고서를 작성하려함
--사원정보(employees) 테이블에서 급여가 $7,000 ~ $10,000 범위 이외인 사람의 이름과 성 및 급여를 급여가 적은순서로 출력
SELECT FIRST_NAME , LAST_NAME , SALARY 
FROM EMPLOYEES e 
WHERE SALARY NOT BETWEEN 7000 AND 10000
ORDER BY SALARY ASC;

--4.사원의 성(LAST_NAME) 중에 'e' 및 'o' 글자가 포함된 사원을 출력
SELECT *
FROM EMPLOYEES e 
WHERE LAST_NAME LIKE '%e%' AND LAST_NAME LIKE '%o%';

--5.급여(salary)와 수당(commision_pct)에 대한 지출 보고서를 작성하려고 한다
--수당을 받는(null이 아닌) 모든 사원의 이름과 성, 급여, 업무, 수당율을 출력하시오
--이 때 급여가 큰 순서대로 정렬하되, 급여가 같으면 수당율이 큰 순서대로 정렬
SELECT FIRST_NAME , LAST_NAME , SALARY , JOB_ID , COMMISSION_PCT 
FROM EMPLOYEES e 
WHERE COMMISSION_PCT IS NOT NULL
ORDER BY SALARY DESC, COMMISSION_PCT DESC;



--230118 3교시
SELECT * FROM EMPLOYEES e ;
SELECT * FROM LOCATIONS l ;
SELECT * FROM DEPARTMENTS d ;
SELECT * FROM DEPARTMENTS WHERE DEPARTMENT_ID = 10;


--230118 7교시 특정 문자열을 포함한 데이터 찾기
SELECT * FROM LOCATIONS l 
WHERE STREET_ADDRESS LIKE '%'a'%';

--7교시 예제 query문
SELECT EMPLOYEE_ID , LAST_NAME , FIRST_NAME , JOB_ID , DEPARTMENT_ID 
FROM EMPLOYEES e 
ORDER BY HIRE_DATE DESC;

SELECT * FROM EMPLOYEES e WHERE EMPLOYEE_ID = 100;

SELECT * FROM EMPLOYEES e WHERE LAST_NAME LIKE '%e%';


--230119 2교시
---------------------------INSERT----------------------------------
--1. INSERT INTO 테이블명 (컬럼명1, 컬럼명2, ...) values(값1, 값2, ...)
SELECT * FROM REGIONS r ;

ROLLBACK;

INSERT INTO REGIONS (REGION_ID, REGION_NAME)
VALUES (5, 'Test');

INSERT INTO REGIONS (REGION_NAME, REGION_ID)
VALUES ('Test2', 6); --values에 넣을 값의 순서는 위에 INSERT에 선언한 regions의 컬럼명 순서를 따라가면 된다

INSERT INTO REGIONS (REGION_ID, REGION_NAME)
VALUES (7, NULL); --나중에 데이터를 넣으려고 할때. 그러나 제약조건같은게 있을경우 컬럼내에 NULL을 넣을 수 없다

INSERT INTO REGIONS (REGION_ID)
VALUES (8); -- 이렇게 넣어도 성공은 함. NULL이 들어간다.

--INSERT INTO REGIONS (REGION_ID, REGION_NAME)
--VALUES (9); -- 제약조건때문에 에러 / 컬럼명, 값의 갯수가 맞지않아 에러가 발생함.

--INSERT INTO REGIONS (REGION_ID, REGION_NAME)
--VALUES (NULL, NULL); --제약조건때문에 에러


--INSERT할때 두번째 방식(COLUMN을 생략하는 방법)
INSERT INTO REGIONS 
VALUES (9, 'Test3');

INSERT INTO REGIONS 
VALUES (10, NULL);

--INSERT INTO REGIONS 
--VALUES (11); -- 에러발생, REGIONS 테이블의 컬럼은 2개 넣은값은 1개


--------------------------------DELETE------------------------------------
SELECT * FROM REGIONS r ;

ROLLBACK;

DELETE REGIONS WHERE REGION_ID = 5;

DELETE REGIONS WHERE REGION_ID IN (7, 8, 10);
DELETE REGIONS WHERE REGION_NAME IS NULL; --데이터가 많이 있을때 데이터값이 NULL인걸 지우고 싶을땐 이걸 쓰는게 맞다

DELETE REGIONS WHERE REGION_NAME LIKE '%Test%';

SELECT * FROM COUNTRIES c ;

INSERT INTO COUNTRIES (COUNTRY_ID, COUNTRY_NAME, REGION_ID)
VALUES ('ZZ', 'Test', 2);

INSERT INTO COUNTRIES (COUNTRY_ID, COUNTRY_NAME, REGION_ID) --COUNTRY_ID에는 제약조건이 걸려있다
VALUES ('ZZA', 'Test2', 2); --에러 COUNTRY_ID에는 최대 2개의 문자열만 들어갈 수 있음.(type : char(2) - 최대2글자 char타입)

--INSERT INTO COUNTRIES (COUNTRY_ID, COUNTRY_NAME, REGION_ID) --COUNTRY_ID에는 제약조건이 걸려있다
--VALUES ('ZA', 'Test2', 10);


--230119 3교시
--DELETE REGIONS WHERE REGION_ID = 2; -- REGION_ID = 2인 데이터를 참조하는 데이터가 있으면 무결성 제약조건에 위배되어 에러가 뜸.

SELECT * FROM DEPARTMENTS;

SELECT * FROM SEQ; --User가 가지고있는 SEQUENCE 목록을 보여줌
--sequence를 이용하면 중복되지 않은 데이터를 좀 더 편하게 집어넣을 수 있다

INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
VALUES (DEPARTMENTS_SEQ.NEXTVAL, 'TestIT', NULL, 1700);

DELETE DEPARTMENTS WHERE DEPARTMENT_ID = 290;


--230119 4교시
--insert, delete 메서드 작성하기, 쿼리문 작성하기
SELECT * FROM LOCATIONS;

INSERT INTO LOCATIONS (LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID)
VALUES (LOCATIONS_SEQ.NEXTVAL, 'Test1', 0000, 'Test1', NULL, NULL);

DELETE LOCATIONS WHERE LOCATION_ID = ?;


--5교시
--------------------------------UPDATE-----------------------------------
SELECT * FROM DEPARTMENTS d ;

ROLLBACK;
COMMIT;

UPDATE DEPARTMENTS SET MANAGER_ID = NULL, DEPARTMENT_NAME = 'ITTest'
WHERE DEPARTMENT_ID = 330;


--6~8교시 예제
SELECT * FROM LOCATIONS;

DELETE LOCATIONS WHERE LOCATION_ID = 3900;

UPDATE LOCATIONS SET STREET_ADDRESS = 'Test2', POSTAL_CODE = '01234'
WHERE LOCATION_ID = 4100;


------employees
SELECT * FROM EMPLOYEES e;
SELECT MANAGER_ID FROM EMPLOYEES e ;
ROLLBACK;
COMMIT;

INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES (EMPLOYEES_SEQ.NEXTVAL, 'QU', 'KING', 'KEIWN', '123.456.7890', sysdate, 'HR_REP', 5000, 0.1, 101, 10);

DELETE EMPLOYEES WHERE EMPLOYEE_ID = 209;

UPDATE EMPLOYEES SET FIRST_NAME = 'ASD', LAST_NAME = 'DDD', EMAIL = 'ASDRGE', SALARY ='12311', COMMISSION_PCT = NULL
WHERE EMPLOYEE_ID = 210;


--230119 8교시 Function
--Table이 없는 경우에 사용하는 Table : DUAL
SELECT 1+1
FROM DUAL;

--SUM, AVG, COUNT
SELECT SALARY, COMMISSION_PCT FROM EMPLOYEES e ;
-- error : SELECT SARARY, SUM(SALARY) FROM EMPLOYEES e ;
SELECT SUM(SALARY), AVG(SALARY) FROM EMPLOYEES e ; --이건 잘 보인다.
SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES e ;
SELECT SUM(COMMISSION_PCT), AVG(COMMISSION_PCT), COUNT(COMMISSION_PCT) FROM EMPLOYEES e ;
SELECT SUM(COMMISSION_PCT)/COUNT(EMPLOYEE_ID), AVG(COMMISSION_PCT) FROM EMPLOYEES e ;
--Primary Key : 무결성 제약조건(중복이 되면 안됨, NULL이 들어갈 수 없음), 즉 위와같은 계산을 할떄는 PK를 기준(NULL이 없는)으로 해야 정확한 계산이 가능함

--MAX, MIN
SELECT MAX(SALARY), MIN(SALARY) FROM EMPLOYEES e ;
SELECT MAX(HIRE_DATE), MIN(HIRE_DATE) FROM EMPLOYEES e ;
-- error : SELECT AVG(HIRE_DATE) FROM EMPLOYEES e ;
SELECT MAX(LAST_NAME), MIN(LAST_NAME) FROM EMPLOYEES e ;



--230120 금 1~3교시
--100번 부서에 근무하는 사원들의 평균 급여와, 그 부서에 급여중 제일 큰 금액, 제일 낮은 금액 출력
SELECT * FROM EMPLOYEES e ;

SELECT AVG(SALARY), MAX(SALARY), MIN(SALARY) FROM EMPLOYEES e --일단 AVG, MAX, MIN을 써놓고 필수로 와야하는 FROM까지 써놓고 그 후에 생각
WHERE DEPARTMENT_ID = 100;

--부서별로 평균급여, 큰금액, 작은금액
--부서의 평균급여가 10000 이상인곳만 보고싶다
SELECT DEPARTMENT_ID, AVG(SALARY), MAX(SALARY), MIN(SALARY) --5번
FROM EMPLOYEES e --1번
WHERE MANAGER_ID IS NOT NULL --2번
GROUP BY DEPARTMENT_ID --3번, 그룹(부서별)을 묶을때 사용하는 것. WHERE로는 해결할 수 없다.
HAVING AVG(SALARY) < 10000 --4번, 그룹에 조건을 줄때 사용.(WHERE는 개개인에게 조건을 걸때 쓰고, HAVING은 그룹에 조건을 줌)
ORDER BY 2 ASC; --6번(SELECT의 결과물에 해당하는 COLUMN명을 써야함)
--WHERE DEPARTMENT_ID = ? --여기서 부서별로 표현하려면 어떻게 하지? 이건 못쓴다.

--매니저별 사원 수
SELECT MANAGER_ID, COUNT(EMPLOYEE_ID), AVG(SALARY) --4
FROM EMPLOYEES e --1
GROUP BY MANAGER_ID --2
HAVING MANAGER_ID IS NOT NULL--3
ORDER BY 1 ASC; --5


--2. 단일함수

--NULL함수
SELECT * FROM DEPARTMENTS d ;

SELECT DEPARTMENT_NAME, NVL(MANAGER_ID, 200) -- SELECT는 데이터를 가지고올때 조작함, TABLE에는 영향이 없다
FROM DEPARTMENTS d ;

SELECT SUM(COMMISSION_PCT)/COUNT(EMPLOYEE_ID), AVG(COMMISSION_PCT)
FROM EMPLOYEES e; 

--평균이나 합계 낼때 NULL처리를 이런식으로 한다.
SELECT SUM(COMMISSION_PCT)/COUNT(EMPLOYEE_ID), AVG(NVL(COMMISSION_PCT, 0)) 
FROM EMPLOYEES e 

SELECT DEPARTMENT_NAME , NVL2(MANAGER_ID, 100, 200) --JAVA에서 삼항연산자 같은 느낌
FROM DEPARTMENTS d ;

--숫자함수 > JAVA에서 동일한 역할을 하는 클래스가 java.lang.math에 있다.
SELECT ABS(-2.3) ABS FROM DUAL;
SELECT FLOOR(3.14159265358979) FLOOR FROM DUAL;
SELECT ROUND(3.14159265358979, -1) ROUND FROM DUAL;

SELECT DEPARTMENT_ID , UPPER(DEPARTMENT_NAME)
FROM DEPARTMENTS d ;

SELECT RPAD('abc', 10, '*') FROM DUAL;
SELECT LPAD('abc', 10, '%') FROM DUAL;

-- 'myData' 를 m*****로 보이게
--이런 문제를 바로 해결하기가 어려우면 결과값이 나오게끔 먼저 만들어놓고 하나씩 바꿔보자
SELECT RPAD('m', 6, '*') FROM DUAL;
SELECT RPAD(SUBSTR('myData', 1, 1), LENGTH('myData'), '*') RPAD FROM DUAL;

SELECT * FROM EMPLOYEES e ;

--FIRST NAME의 첫글자만 나오고 나머지는 *로
--SELECT RPAD(컬럼명, 포현할너비, 채울문자) RPAD FROM DUAL;
SELECT EMPLOYEE_ID, RPAD(SUBSTR(FIRST_NAME, 0, 1), LENGTH(FIRST_NAME), '*') RPAD FROM EMPLOYEES e ;

--날짜함수
SELECT SYSDATE, SYSTIMESTAMP , CURRENT_DATE , CURRENT_TIMESTAMP FROM DUAL;

SELECT SYSDATE, SYSDATE+3, SYSDATE-10 FROM DUAL;

SELECT ADD_MONTHS(SYSDATE, +5) FROM DUAL; 

SELECT EMPLOYEE_ID, MONTHS_BETWEEN(CURRENT_DATE, HIRE_DATE) FROM EMPLOYEES e ; --이걸 정리하면 아래처럼
SELECT EMPLOYEE_ID, ROUND(FLOOR(MONTHS_BETWEEN(CURRENT_DATE, HIRE_DATE))/12, 1)||'년' AS YEAR FROM EMPLOYEES e ;

SELECT NEXT_DAY(SYSDATE, 4) FROM DUAL; 

SELECT LAST_DAY(SYSDATE) FROM DUAL; -- 얘는 달력만들때 사용


--형변환 함수 (숫자 <-> 문자열 <-> 날짜)

SELECT SYSDATE , TO_CHAR(SYSDATE, 'YYYY/MM/DD DAY HH24:MI') FROM DUAL;
--DTO의 Date 타입을 Date가 아니라 String으로 만들었을 때
SELECT TO_CHAR(1234, '9,999,999') FROM DUAL; 

-- TO_NUMBER
SELECT TO_NUMBER('123')*2 FROM DUAL;
SELECT TO_NUMBER('1,234', '9,999')*2 FROM DUAL; --구분자(,)가 있으면 알려주자
SELECT TO_NUMBER('1.23')*2 FROM DUAL; 

--TO_DATE
SELECT TO_DATE('2023.3.12') FROM DUAL;




----------------------------------
SELECT * FROM EMPLOYEES e ;

--회사에서 자주 할만한거. **TABLE의 구조를 알아둬야한다.
--LAST_NAME이 King이 근무하는 부서명을 Query문을 쳐서 알아내기(Query문은 몇번을 쳐도 상관없다.)
SELECT LAST_NAME, DEPARTMENT_ID 
FROM EMPLOYEES e 
WHERE LAST_NAME = 'King';

SELECT DEPARTMENT_NAME 
FROM DEPARTMENTS d 
WHERE DEPARTMENT_ID IN (90, 80);


------King이 근무하는 부서의 대륙은 어디에 있나?
--눈으로 따라가지말고 실제 쿼리를 치면서 생각해보자.
SELECT DEPARTMENT_ID 
FROM EMPLOYEES e 
WHERE LAST_NAME = 'King';

SELECT * FROM DEPARTMENTS d ;

SELECT LOCATION_ID 
FROM DEPARTMENTS d 
WHERE DEPARTMENT_ID IN (90, 80);

SELECT * FROM LOCATIONS l ;

SELECT COUNTRY_ID 
FROM LOCATIONS l 
WHERE LOCATION_ID IN (2500, 1700)

SELECT * FROM COUNTRIES c ;

SELECT REGION_ID 
FROM COUNTRIES c 
WHERE COUNTRY_ID IN ('US', 'UK');

SELECT * FROM REGIONS r ;

SELECT REGION_NAME 
FROM REGIONS r 
WHERE REGION_ID IN (1, 2);


--도시명 시애틀에서 근무하는 모든사람들의 정보를 출력
SELECT LOCATION_ID 
FROM LOCATIONS l 
WHERE CITY  = 'Seattle';

SELECT DEPARTMENT_ID 
FROM DEPARTMENTS d 
WHERE LOCATION_ID = 1700;

--DEPARTMENT_ID = 10, 30, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 330

SELECT *
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID IN (10, 30, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 330);


--------------------------------------
--------230120 5교시, subquery
--이 결과물을 한번만 실행해서 보고싶다면?

SELECT DEPARTMENT_ID 
FROM EMPLOYEES e 
WHERE LAST_NAME = 'King';

SELECT * FROM DEPARTMENTS d ;

--다중행(Multi-row) 서브쿼리
 -- 연산자 IN, NOT IN, any, all, exist.
SELECT LOCATION_ID 
FROM DEPARTMENTS d 
WHERE DEPARTMENT_ID IN (
	SELECT DEPARTMENT_ID 
	FROM EMPLOYEES e 
	WHERE LAST_NAME = 'King'
);
	--이렇게 쓰는 쿼리를 subquery라고 부른다

-- Austin이 근무하는 대륙의 이름을 찾아보자. 단, subquery로

SELECT REGION_NAME 
FROM REGIONS r 
WHERE REGION_ID = (
	SELECT REGION_ID 
	FROM COUNTRIES c 
	WHERE COUNTRY_ID = (
		SELECT COUNTRY_ID 
		FROM LOCATIONS l 
		WHERE LOCATION_ID = (
			SELECT LOCATION_ID  
			FROM DEPARTMENTS d   
			WHERE DEPARTMENT_ID =( 
				SELECT DEPARTMENT_ID  
				FROM EMPLOYEES e 
				WHERE LAST_NAME = 'Austin'
			)
		)
	)
);
					
					
SELECT DEPARTMENT_NAME
FROM DEPARTMENTS d
WHERE DEPARTMENT_ID = ?;

SELECT DEPARTMENT_ID 
FROM EMPLOYEES e 
WHERE LAST_NAME = 'Austin';
	
					
--사원들의 정보, 평균 급여보다 많이 받는 사원들의 정보
--SELECT *
--FROM EMPLOYEES e 
--WHERE SALARY > AVG(SALARY); --에러 발생.

SELECT *
FROM EMPLOYEES e 
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES e);

--First_name이 john인 사람의 관리자의 first_name?
SELECT FIRST_NAME 
FROM EMPLOYEES e2 
WHERE EMPLOYEE_ID =
	(
		SELECT MANAGER_ID 
		FROM EMPLOYEES e 
		WHERE FIRST_NAME = 'Lex'
	);


--사원들 중에서 급여를 제일 많이 받는 사원과 같은 부서에 근무하는 사원들의 평균 급여?
--급여를 제일 많이 받는 사원의 디파트먼트ID가 필요
--그사람의 디파트먼트ID와 같은 사람들을 찾기
--찾은 사람들의 평균 급여 구하기

--SELECT DEPARTMENT_ID
--FROM EMPLOYEES;
--WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEES e);



SELECT AVG(SALARY)
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID =
	(
		SELECT DEPARTMENT_ID
		FROM EMPLOYEES
		WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEES e);
	);

--* 짜기 힘들면 하나씩 분리해서 따로따로 생각해보는 연습을 해라.
--신입사원의 이름, 최고참의 이름이 나란히 출력되도록(First_name으로)
--이름출력?
SELECT 'A' 'B'

--신참
SELECT MAX(HIRE_DATE) FROM EMPLOYEES e ;
--신참 이름
SELECT FIRST_NAME FROM EMPLOYEES e WHERE HIRE_DATE =
(SELECT MAX(HIRE_DATE) FROM EMPLOYEES e);

--최고참
SELECT MIN(HIRE_DATE) FROM EMPLOYEES e ;
--최고참 이름
SELECT FIRST_NAME FROM EMPLOYEES e WHERE HIRE_DATE =
(SELECT MIN(HIRE_DATE) FROM EMPLOYEES e);

--최종(SELECT에도 서브쿼리를 넣을 수 있다)
SELECT 
	(SELECT FIRST_NAME FROM EMPLOYEES e WHERE HIRE_DATE =
	(SELECT MAX(HIRE_DATE) FROM EMPLOYEES e)) AS NEWBIE,
	(SELECT FIRST_NAME FROM EMPLOYEES e WHERE HIRE_DATE =
	(SELECT MIN(HIRE_DATE) FROM EMPLOYEES e)) AS OLDBIE
FROM DUAL;


----REGION_ID가 중복이 되지 않게 최대값에서 +1씩 시키는 쿼리 만들어서 서브쿼리로 넣기
SELECT * FROM REGIONS r ;

INSERT INTO REGIONS (REGION_ID, REGION_NAME)
VALUES ((SELECT MAX(REGION_ID)+1 FROM REGIONS r), 'Mars');

SELECT MAX(REGION_ID)+1 FROM REGIONS r ;

--이렇게도 쓸 수 있다.(SELECT의 결과물을 또 다른 TABLE로 보는 것)
SELECT A.SALARY, A.SALARY*2 FROM
(SELECT LAST_NAME, SALARY, DEPARTMENT_ID 
FROM EMPLOYEES e) A;

