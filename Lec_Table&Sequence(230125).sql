
--230125 7교시
--회원가입
--이름, ID, PW, 전화번호, 이메일, 나이

CREATE TABLE MEMBER(
	ID VARCHAR2(50),
	PW VARCHAR2(50),
	NAME VARCHAR2(50),
	PHONE VARCHAR2(50),
	EMAIL VARCHAR2(100),
	AGE NUMBER(3)
);

SELECT * FROM MEMBER;
DROP TABLE MEMBER;
TRUNCATE TABLE MEMBER;
DELETE MEMBER;

INSERT INTO MEMBER(ID, PW, NAME, PHONE, EMAIL, AGE)
VALUES('test', 'test1', 'test', '010-1111-2222', 'test@gmail.com', 30);

INSERT INTO MEMBER(ID, PW, NAME, PHONE, EMAIL, AGE)
VALUES('test1', 'test', 'test', NULL, NULL, 20);

INSERT INTO MEMBER(ID, PW, NAME, PHONE, EMAIL, AGE)
VALUES('test2', 'test', 'test', '0101111', NULL, 20);

--결함이 있는 데이터를 못들어오게 막아주는것 : 제약조건
SELECT * FROM USER_CONSTRAINTS ;

CREATE TABLE MEMBER(
	ID VARCHAR2(50) PRIMARY KEY,
	PW VARCHAR2(50) NOT NULL,
	NAME VARCHAR2(50),
	PHONE VARCHAR2(50) UNIQUE,
	EMAIL VARCHAR2(100),
	AGE NUMBER(3) CHECK (AGE BETWEEN 0 AND 120)
);
--위와 같이 주면 제약조건에 위배 됐을때 문제점을 발견하기가 힘들다. (이렇게 쓰지 마세요)


-- 1. column 레벨 방식
CREATE TABLE MEMBER(
	ID VARCHAR2(50) CONSTRAINT MEMBER_ID_PK PRIMARY KEY,
	PW VARCHAR2(50) CONSTRAINT MEMBER_PW_NN NOT NULL,
	NAME VARCHAR2(50),
	PHONE VARCHAR2(50) CONSTRAINT MEMBER_PHONE_U UNIQUE,
	EMAIL VARCHAR2(100) CONSTRAINT MEMBER_EMAIL_U UNIQUE,
	AGE NUMBER(3) CHECK (AGE > 0 AND AGE < 120)
);


-- 2. table 레벨 방식
CREATE TABLE MEMBER(
	ID VARCHAR2(50),
	PW VARCHAR2(50) CONSTRAINT MEMBER_PW_NN NOT NULL,
	NAME VARCHAR2(50),
	PHONE VARCHAR2(50),
	EMAIL VARCHAR2(100),
	AGE NUMBER(3) CHECK (AGE > 0 AND AGE < 120),
	CONSTRAINT MEMBER_ID_PK PRIMARY KEY (ID),
	CONSTRAINT MEMBER_PHONE_U UNIQUE (PHONE),
	CONSTRAINT MEMBER_EMAIL_U UNIQUE (EMAIL)
);


-- 게시판을 만들려고 함. 컬럼레벨방식으로/테이블레벨방식 FK는 약간 다르다.(누구한테 제약조건을 걸건지에 대한 내용 추가)
CREATE TABLE BOARD(
	NUM NUMBER CONSTRAINT BOARD_NUM_PK PRIMARY KEY,
	TITLE VARCHAR2(200),
	CONTENTS CLOB, --최대 4GB까지 담을 수 있어서 데이터 제한을 줄 필요가 없음
	WRITER VARCHAR2(50), --CONSTRAINT BOARD_W_FK REFERENCES MEMBER(ID),
	REGDATE DATE,
	HIT NUMBER,
	CONSTRAINT BOARD_WRITER_FK FOREIGN KEY (WRITER) REFERENCES MEMBER (ID) ON DELETE SET NULL --ON DELETE CASCADE
);
--BOARD의 WRITER가 MEMBER의 ID를 참조해야한다.(ID 없이 글을 쓸 수 없기 때문에)
--MEMBER가 항상 글을 쓸 필요는 없지만, 쓰여진 글은 MEMBER가 꼭 필요하다(이게 Foregin Key)
SELECT * FROM BOARD;
DROP TABLE BOARD;

INSERT INTO MEMBER(ID, PW, NAME, PHONE, EMAIL, AGE)
VALUES('W1', 'test1', 'test', '010-1111-2200', 'test1@gmail.com', 30);

INSERT INTO BOARD 
VALUES(BOARD_SEQ.NEXTVAL, 'T1', 'C1', 'W1', sysdate, 0);

DELETE MEMBER WHERE ID = 'W1';
DELETE BOARD WHERE NUM = 1;


--230126 1교시
--TABLE에서 CREATE NEW TABLE을 통해서 TABLE 만들어봄
SELECT * FROM ADDRESS;

DROP TABLE ADDRESS;

INSERT INTO ADDRESS 
VALUES (1, 'IU', '0102222', 'iu@naver.com');

--삭제된 정보들은 휴지통으로 간다
SELECT * FROM RECYCLEBIN;

--휴지통 완전히 비우기
PURGE RECYCLEBIN;

--데이터 지웠을때 복원하기 기능
FLASHBACK TABLE MEMBER TO BEFORE DROP;

--2교시
--TABLE 수정하기(ALTER)
SELECT * FROM MEMBER;

--COLUMN 추가
ALTER TABLE "MEMBER" ADD (BIRTH DATE);
--COLUMN 삭제
ALTER TABLE "MEMBER" DROP COLUMN BIRTH;
--COLUMN명 수정
ALTER TABLE "MEMBER" RENAME COLUMN ID TO USERNAME;

--COLUMN의 DATATYPE 변경
UPDATE "MEMBER" SET PHONE = NULL;
ALTER TABLE "MEMBER" MODIFY (PHONE NUMBER);

--제약조건 수정
SELECT * FROM USER_CONSTRAINTS ; --사용자 제약조건 확인
--제약조건 삭제
ALTER TABLE "MEMBER" DROP CONSTRAINT MEMBER_PHONE_U;
--제약조건 추가
ALTER TABLE "MEMBER" ADD CONSTRAINT MEMBER_PHONE_U UNIQUE (PHONE);


--3교시
--일반적으로 table에 제약조건을 거는 방법(table 생성 -> 제약조건(pk제외) 차후에 추가)
CREATE TABLE BOARD(
	NUM NUMBER CONSTRAINT BOARD_NUM_PK PRIMARY KEY,
	TITLE VARCHAR2(200),
	CONTENTS CLOB, --최대 4GB까지 담을 수 있어서 데이터 제한을 줄 필요가 없음
	WRITER VARCHAR2(50), --CONSTRAINT BOARD_W_FK REFERENCES MEMBER(ID),
	REGDATE DATE,
	HIT NUMBER
	--CONSTRAINT BOARD_WRITER_FK FOREIGN KEY (WRITER) REFERENCES MEMBER (ID) ON DELETE SET NULL --ON DELETE CASCADE
);

--제약조건 추가
ALTER TABLE "BOARD" ADD CONSTRAINT BOARD_W_FK FOREIGN KEY (WRITER) REFERENCES MEMBER (ID) ON DELETE CASCADE;

RENAME MEMBER TO USERS;
RENAME USERS TO MEMBER;
SELECT * FROM USERS;


--시퀀스
SELECT * FROM SEQ;

CREATE SEQUENCE BOARD_SEQ; --시작번호1 증가값1
--아래쪽은 옵션, 그러나 보통 위에 한줄만 써도 PK용도로 쓰는 시퀀스는 잘 작동한다.
START WITH 1       --시작번호를 지정
INCREMENT BY 1     --증가값을 지정
NOMAXVALUE
NOMINVALUE
NOCYCLE
NOCASHE

SELECT BOARD_SEQ.CURRVAL FROM DUAL;